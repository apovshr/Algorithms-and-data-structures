# створюємо два масиви: початковий час та кінець
s = [3, 4, 5, 7, 9, 11, 13, 15, 10, 6, 8, 11, 2]
f = [5, 8, 9, 9, 12, 15, 17, 18, 11, 9, 12, 13, 4]

# основна функція з підрахунками
def activities (s, f):
  
    activities = list(zip(s, f)) # з'єднуємо початок та кінець завдань разом
    print('Cписок активностей (початковий): ', activities)
    activities.sort(key = lambda x: (x[1], x[0])) # сортуємо, щоб час кінця був по зростанню, щоб програма працювала
  

    A = [activities[0]] # початкове завдання під індексом 0
    j = 0 # індекс поточного завдання

    # алгоритм, який буде порівнювати чи початок >= кінцю попереднього завдання та додавати у масив оптимального рішення
    for i in range(1, len(activities)):
        if activities[i][0] >= activities[j][1]:
            A.append(activities[i])
            j = i

    # виводимо оптимальний список
    print('\nОптимальний список активностей: ', A)

# виклик основної функції
activities(s, f)

